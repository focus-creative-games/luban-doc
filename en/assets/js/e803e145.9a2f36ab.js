"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3569],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>b});var l=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,l,n=function(e,t){if(null==e)return{};var a,l,n={},r=Object.keys(e);for(l=0;l<r.length;l++)a=r[l],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)a=r[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var m=l.createContext({}),p=function(e){var t=l.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=p(e.components);return l.createElement(m.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},c=l.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,m=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=p(a),c=n,b=u["".concat(m,".").concat(c)]||u[c]||d[c]||r;return a?l.createElement(b,i(i({ref:t},s),{},{components:a})):l.createElement(b,i({ref:t},s))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=c;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o[u]="string"==typeof e?e:n,i[1]=o;for(var p=2;p<r;p++)i[p]=a[p];return l.createElement.apply(null,i)}return l.createElement.apply(null,a)}c.displayName="MDXCreateElement"},8741:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var l=a(7462),n=(a(7294),a(3905));const r={},i="Auto-Imported Table",o={unversionedId:"manual/importtable",id:"manual/importtable",title:"Auto-Imported Table",description:"Each new table is added to tables.xlsx, which is a tedious task. In most cases, each excel corresponds to a table, and it is possible to let the tool automatically add the table definition.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/importtable.md",sourceDirName:"manual",slug:"/manual/importtable",permalink:"/en/docs/manual/importtable",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"configuration definition",permalink:"/en/docs/manual/defaultschemacollector"},next:{title:"Command line tools",permalink:"/en/docs/manual/commandtools"}},m={},p=[{value:"Default TableImporter",id:"default-tableimporter",level:2},{value:"Default scanning rules",id:"default-scanning-rules",level:3},{value:"Custom import rules",id:"custom-import-rules",level:3},{value:"Implement a custom TableImporter",id:"implement-a-custom-tableimporter",level:2},{value:"Limitations",id:"limitations",level:2}],s={toc:p},u="wrapper";function d(e){let{components:t,...a}=e;return(0,n.kt)(u,(0,l.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"auto-imported-table"},"Auto-Imported Table"),(0,n.kt)("p",null,"Each new table is added to ",(0,n.kt)("strong",{parentName:"p"},"tables"),".xlsx, which is a tedious task. In most cases, each excel corresponds to a table, and it is possible to let the tool automatically add the table definition."),(0,n.kt)("p",null,"Since version v3.0.0, automatic table import is supported. luban will scan the excel table according to the specified rules and automatically add the corresponding table."),(0,n.kt)("h2",{id:"default-tableimporter"},"Default TableImporter"),(0,n.kt)("p",null,"The default TableImporter is DefaultTableImporter, and the corresponding name is default. If the ",(0,n.kt)("inlineCode",{parentName:"p"},"-x tableImporter.name")," parameter is not specified, DefaultTableImporter is automatically used."),(0,n.kt)("h3",{id:"default-scanning-rules"},"Default scanning rules"),(0,n.kt)("p",null,"The DefaultTableImporter scans the luban.conf directory (including subdirectories) for all Excel files (xls, xlsx, xlm, and csv) with file names beginning with #, such as ",(0,n.kt)("inlineCode",{parentName:"p"},"#Item.xlsx"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"#Task-\u4efb\u52a1\u8868.xlsx"),", and ",(0,n.kt)("inlineCode",{parentName:"p"},"reward/#Reward.xlsx"),"."),(0,n.kt)("p",null,"The table's valueType is the string after removing the leading '#' character, the file suffix, and the ",(0,n.kt)("inlineCode",{parentName:"p"},"-xxxx"),' comment at the end of the file name. "Tb" is appended to the valueType name as the full table name. The table\'s comment is automatically set to ',(0,n.kt)("inlineCode",{parentName:"p"},"xxx"),". If the Excel file is in a subdirectory, the subdirectory is used as the namespace."),(0,n.kt)("p",null,"The table comment is optional; both ",(0,n.kt)("inlineCode",{parentName:"p"},"#Item.xlsx")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"#Item-\u5177\u8868.xlsx")," are valid default import table names."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"#Item.xlsx")," generates a table with full_name of TbItem, value_type of Item, and mode=map"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"reward/#Reward.xlsx")," generates a table with full_name of reward.TbReward, value_type of reward.Reward, and mode=map"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"item/equip/#Equip.csv")," generates a table with full_name of item.equip.TbEquip, value_type of item.equip.Equip, and mode=map")),(0,n.kt)("h3",{id:"custom-import-rules"},"Custom import rules"),(0,n.kt)("p",null,"Introduce several definitions:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Variable"),(0,n.kt)("th",{parentName:"tr",align:null},"Definition"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"RawFullName"),(0,n.kt)("td",{parentName:"tr",align:null},"The relative path of all directories in the file is converted into a namespace ('\\' or '/' in the path is replaced by '.') and then concatenated with the value of the first Group in the tableImporter.filePattern regular item. Taking ",(0,n.kt)("inlineCode",{parentName:"td"},"filePatter=#(.*)")," and the file name ",(0,n.kt)("inlineCode",{parentName:"td"},"#Item.xlsx")," as an example, RawFullName is Item; taking the file name ",(0,n.kt)("inlineCode",{parentName:"td"},"item/#Item.xlsx")," as an example, RawFullName is item.Item")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"RawNamespace"),(0,n.kt)("td",{parentName:"tr",align:null},"The namespace in RawFullName, if RawFullName is item.Item, then RawNamespace is item")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"RawName"),(0,n.kt)("td",{parentName:"tr",align:null},"The class name in RawFull, if RawFullName is item.Item, then RawName is Item")))),(0,n.kt)("p",null,"Configuration parameters related to custom rules:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,n.kt)("th",{parentName:"tr",align:null},"Required"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"),(0,n.kt)("th",{parentName:"tr",align:null},"Example"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tableImporter.name"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"TableImporter name, the default implementation is DefaultTableImporter, the name is default. If none is selected, automatic import is disabled"),(0,n.kt)("td",{parentName:"tr",align:null},"-x tableImporter.name=default")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tableImporter.filePattern"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The file name rule for automatic import (without the file name suffix), the format is a C# regular expression string. The default is #(.*)"),(0,n.kt)("td",{parentName:"tr",align:null},"-x tableImporter.filePattern=!(.*)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tableImporter.tableNamespaceFormat"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The format string of the table namespace, the default value is ",(0,n.kt)("inlineCode",{parentName:"td"},"{0}"),", that is, directly take RawNamespace"),(0,n.kt)("td",{parentName:"tr",align:null},"-x tableImporter.tableNamespaceFormat=My{0}")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tableImporter.tableNameFormat"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The format string of the table class name, the default value is ",(0,n.kt)("inlineCode",{parentName:"td"},"Tb{0}"),", that is, take Tb plus RawName"),(0,n.kt)("td",{parentName:"tr",align:null},"-x tableImporter.tableNameFormat=Cfg{0}")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tableImporter.valueTypeNameFormat"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The format string of the value_type class name, the default value is ",(0,n.kt)("inlineCode",{parentName:"td"},"{0}"),", that is, take RawName. However, if the table namespace exists, the namespace will be automatically added."),(0,n.kt)("td",{parentName:"tr",align:null},"-x tableImporter.valueTypeNameFormat=Va{0}")))),(0,n.kt)("h2",{id:"implement-a-custom-tableimporter"},"Implement a custom TableImporter"),(0,n.kt)("p",null,"If the default TableImporter does not meet the requirements, you can also implement a custom TableImporter. Refer to the implementation of ",(0,n.kt)("inlineCode",{parentName:"p"},"src/Luban.Schema.Builtin/DefaultTableImporter.cs"),"."),(0,n.kt)("h2",{id:"limitations"},"Limitations"),(0,n.kt)("p",null,"Automatically importing tables can only meet common rules. For more complex input data sources, please manually add them in ",(0,n.kt)("strong",{parentName:"p"},"tables"),".xlsx."),(0,n.kt)("p",null,"There are the following limitations:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Multiple data sources are not supported, that is, multiple excel files are not supported to be exported as one table, for example, ",(0,n.kt)("inlineCode",{parentName:"li"},"#Item_1.xlsx")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"#Item_2.xlsx")," are not supported to be automatically exported as one table"),(0,n.kt)("li",{parentName:"ul"},"Sheet is not supported to be exported as one table, for example, the equip cell sheet in ",(0,n.kt)("inlineCode",{parentName:"li"},"Item.xlsx")," is not supported to be automatically exported as one table"),(0,n.kt)("li",{parentName:"ul"},"Only map mode is supported, not one or index mode")))}d.isMDXComponent=!0}}]);