"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9730],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>c});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var m=a.createContext({}),p=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(m.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,m=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=p(n),k=l,c=d["".concat(m,".").concat(k)]||d[k]||u[k]||r;return n?a.createElement(c,i(i({ref:t},s),{},{components:n})):a.createElement(c,i({ref:t},s))}));function c(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=k;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o[d]="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},4086:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),l=(n(7294),n(3905));const r={},i="Non-Excel data source",o={unversionedId:"manual/otherdatasource",id:"manual/otherdatasource",title:"Non-Excel data source",description:"Not all configuration data is saved in Excel format. In actual projects, some complex configurations are generated by editors, which are generally saved in formats such as json or xml. luban currently",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/otherdatasource.md",sourceDirName:"manual",slug:"/manual/otherdatasource",permalink:"/en/docs/manual/otherdatasource",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Excel compact format",permalink:"/en/docs/manual/excelcompactformat"},next:{title:"Code and Data Generation",permalink:"/en/docs/manual/generatecodedata"}},m={},p=[{value:"Types used for demonstration",id:"types-used-for-demonstration",level:2},{value:"Data directory",id:"data-directory",level:2},{value:"Single record format",id:"single-record-format",level:2},{value:"json format",id:"json-format",level:3},{value:"lua format",id:"lua-format",level:3},{value:"xml format",id:"xml-format",level:3},{value:"yaml format",id:"yaml-format",level:3},{value:"lite format",id:"lite-format",level:2},{value:"Compound file format",id:"compound-file-format",level:2}],s={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,l.kt)(d,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"non-excel-data-source"},"Non-Excel data source"),(0,l.kt)("p",null,"Not all configuration data is saved in Excel format. In actual projects, some complex configurations are generated by editors, which are generally saved in formats such as json or xml. luban currently\nsupports the following data sources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"json"),(0,l.kt)("li",{parentName:"ul"},"lua"),(0,l.kt)("li",{parentName:"ul"},"xml"),(0,l.kt)("li",{parentName:"ul"},"yaml"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"lite"),". Luban's unique concise text data format without field names is suitable for expressing very complex data structures")),(0,l.kt)("h2",{id:"types-used-for-demonstration"},"Types used for demonstration"),(0,l.kt)("p",null,"Take the following DemoType2 as an example to show how to fill in the data corresponding to this type in other file formats."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<bean name="DemoType2" >\n  <var name="x4" type="int"/>\n  <var name="x1" type="bool"/>\n  <var name="x5" type="long"/>\n  <var name="x6" type="float"/>\n  <var name="x7" type="double"/>\n  <var name="x10" type="string"/>\n  <var name="x12" type="DemoType1"/>\n  <var name="x13" type="DemoEnum"/>\n  <var name="x14" type="DemoDynamic#sep=,"/>\n  <var name="t1" type="datetime"/>\n  <var name="k1" type="array,int"/>\n  <var name="k2" type="list,int"/>\n  <var name="k8" type="map,int,int"/>\n  <var name="k9" type="(list#sep=,#index=y1),DemoE2"/>\n  <var name="k15" type="(array#sep=,),DemoDynamic"/> \n</bean>\n\n<table name="TbDataFromSingle" value="DemoType2" input="test/datas"/> \n')),(0,l.kt)("h2",{id:"data-directory"},"Data directory"),(0,l.kt)("p",null,"If table.inputFiles points to a directory, it will automatically traverse the entire directory tree, ignore files starting with the ",(0,l.kt)("inlineCode",{parentName:"p"},".~_")," character, and input the remaining files as data files."),(0,l.kt)("p",null,"These data file formats correspond to the following single record format. Note that if you encounter an excel file, it still defaults to trying to read multiple records from a file."),(0,l.kt)("h2",{id:"single-record-format"},"Single record format"),(0,l.kt)("h3",{id:"json-format"},"json format"),(0,l.kt)("p",null,"Some special points of the json format:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"set type. Filling method is ",(0,l.kt)("inlineCode",{parentName:"li"},"[v1,v2,...]")),(0,l.kt)("li",{parentName:"ul"},"map type. Since json only supports string type keys, the map format is ",(0,l.kt)("inlineCode",{parentName:"li"},"[[k1,v1],[k2,v2]...]")),(0,l.kt)("li",{parentName:"ul"},"Polymorphic bean type. The ",(0,l.kt)("inlineCode",{parentName:"li"},"$type")," attribute is needed to specify the specific type name")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "x1":true,\n  "x2":3,\n  "x3":128,\n  "x4":1,\n  "x5":11223344,\n  "x6":1.2,\n  "x7":1.23432,\n  "x10":"hq",\n  "x12": { "x1":10},\n  "x13":"B",\n  "x14":{"$type": "DemoD2", "x1":1, "x2":2},\n  "t1":"1970-01-01 00:00:00",\n  "k1":[1,2],\n  "k2":[2,3],\n  "k7":[2,3],\n  "k8":[[2,2],[4,10]],\n  "k9":[{"y1":1, "y2":true},{"y1":2, "y2":false}],\n  "k15":[{"$type": "DemoD2", "x1":1, "x2":2}]\n}\n')),(0,l.kt)("h3",{id:"lua-format"},"lua format"),(0,l.kt)("p",null,"Lua \u200b\u200bdata source features:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There is a return before the data, because lua data is loaded as a lua file, and each loaded result is read as a record"),(0,l.kt)("li",{parentName:"ul"},"The format of set is ",(0,l.kt)("inlineCode",{parentName:"li"},"{v1, v2, ...}")),(0,l.kt)("li",{parentName:"ul"},"Unlike json, the key of lua table supports any format, so lua map can directly ",(0,l.kt)("inlineCode",{parentName:"li"},"{[key1] = value1, [key2] = value2, ,,,}")),(0,l.kt)("li",{parentName:"ul"},"Polymorphic bean type. The ",(0,l.kt)("inlineCode",{parentName:"li"},"_type_")," attribute is needed to specify the specific type name")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lua"},'return \n{\n  x1 = false,\n  x2 = 2,\n  x3 = 128,\n  x4 = 1122,\n  x5 = 112233445566,\n  x6 = 1.3,\n  x7 = 1122,\n  x10 = "yf",\n  x12 = {x1=1},\n  x13 = "D",\n  x14 = { _type_="DemoD2", x1 = 1, x2=3},\n  t1 = "1970-01-01 00:00:00",\n  k1 = {1,2},\n  k2 = {2,3},\n  k8 = {[2]=10,[3]=12},\n  k9 = { {y1=1,y2=true}, {y1=10,y2=false} },\n  k15 = { { _type_="DemoD2", x1 = 1, x2=3} },\n}\n')),(0,l.kt)("h3",{id:"xml-format"},"xml format"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<data>\n  <x1>true</x1>\n  <x2>4</x2>\n  <x3>128</x3>\n  <x4>1</x4>\n  <x5>112233445566</x5>\n  <x6>1.3</x6>\n  <x7>1112232.43123</x7>\n  <x10>yf</x10>\n  <x12> <x1>1</x1> </x12>\n  <x13>C</x13>\n  <x14 type="DemoD2">  <x1>1</x1>  <x2>2</x2> </x14>\n  <k1> <item>1</item> <item>2</item> </k1>\n  <k2> <item>1</item> <item>2</item> </k2>\n  <k8>\n      <item> <key>2</key><value>10</value></item>\n      <item> <key>3</key><value>30</value></item>\n  </k8>\n  <k9>\n      <item> <y1>1</y1> <y2>true</y2> </item>\n      <item> <y1>2</y1> <y2>false</y2> </item>\n  </k9>\n  <k15>\n      <item type="DemoD2"> <x1>1</x1> <x2>2</x2> </item>\n  </k15>\n</data>\n')),(0,l.kt)("h3",{id:"yaml-format"},"yaml format"),(0,l.kt)("p",null,"The characteristics of yaml format are similar to json:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"set type. The filling method corresponds to the json list ",(0,l.kt)("inlineCode",{parentName:"p"},"[v1,v2,...]"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"map type. Since json only supports string type keys, the map format filling method for the kv list in json is ",(0,l.kt)("inlineCode",{parentName:"p"},"[[k1,v1],[k2,v2]...]"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"polymorphic bean type. The ",(0,l.kt)("inlineCode",{parentName:"p"},"$type")," attribute is required to specify the specific type name"))),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"Files with the ",(0,l.kt)("inlineCode",{parentName:"p"},"yaml")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"yml")," suffixes will be recognized as yaml files.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"x1: true\nx2: 3\nx3: 128\nx4: 40\nx5: 11223344\nx6: 1.2\nx7: 1.23432\nx10: hq\nx12:\n  x1: 10\nx13: B\nx14:\n  $type: DemoD2\n  x1: 1\n  x2: 2\nt1: '1970-01-01 00:00:00'\nk1:\n- 1\n- 2\nk2:\n- 2\n- 3\nk8:\n- - 2\n  - 2\n- - 4\n  - 10\nk9:\n- y1: 1\n  y2: true\n- y1: 2\n  y2: false\nk15:\n- $type: DemoD2\n  x1: 1\n  x2: 2\n")),(0,l.kt)("h2",{id:"lite-format"},"lite format"),(0,l.kt)("p",null,"Lite format is a text data format unique to luban. Compared with formats such as json, it does not require field names, so it is more concise."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"The suffix of the Lite format file is ",(0,l.kt)("inlineCode",{parentName:"p"},"lit"),", such as ",(0,l.kt)("inlineCode",{parentName:"p"},"abc.lit"),".")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Data type"),(0,l.kt)("th",{parentName:"tr",align:null},"Configuration format"),(0,l.kt)("th",{parentName:"tr",align:null},"Supplementary description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"true, false, 1, 0"),(0,l.kt)("td",{parentName:"tr",align:null},"Case insensitive")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"byte"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"short"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"long"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"float"),(0,l.kt)("td",{parentName:"tr",align:null},"1, 1.0"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"1, 1.0"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"abc, 'abc', \"abc\""),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datetime"),(0,l.kt)("td",{parentName:"tr",align:null},"1970-01-01 00:00:00"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"array"),(0,l.kt)("td",{parentName:"tr",align:null},"{1,2,3}"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"list"),(0,l.kt)("td",{parentName:"tr",align:null},"{1,2,3}"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"set"),(0,l.kt)("td",{parentName:"tr",align:null},"{1,2,3}"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"map"),(0,l.kt)("td",{parentName:"tr",align:null},"{{1,2},{3,4},{5,6}}"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum"),(0,l.kt)("td",{parentName:"tr",align:null},"A"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bean"),(0,l.kt)("td",{parentName:"tr",align:null},"{1,2,3}"),(0,l.kt)("td",{parentName:"tr",align:null},"Start with '{', fill in each field in order, and end with '}'. If it is a nullable polymorphic or ordinary bean, you can directly use ",(0,l.kt)("inlineCode",{parentName:"td"},"null")," to represent null, but not ",(0,l.kt)("inlineCode",{parentName:"td"},"{null}"),". The format of non-null polymorphic bean is ",(0,l.kt)("inlineCode",{parentName:"td"},"{polymorphic type, field 1, field 2,...}"),", that is, the first field is a polymorphic type")))),(0,l.kt)("p",null,"Additional notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Line breaks and blank values \u200b\u200bbefore and after fields in the configuration will be automatically removed, similar to HTML parsing rules"),(0,l.kt)("li",{parentName:"ul"},"Default field values \u200b\u200bare not supported, and blank data will be skipped. For example, ",(0,l.kt)("inlineCode",{parentName:"li"},"{1,,,2}")," is equivalent to ",(0,l.kt)("inlineCode",{parentName:"li"},"{1,2}")),(0,l.kt)("li",{parentName:"ul"},"string does not need to be surrounded by ",(0,l.kt)("inlineCode",{parentName:"li"},"'")," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"')," like in json format. Since blank characters before and after the string are automatically removed when parsing data, if you want to include blank fields in the string, you need to add ",(0,l.kt)("inlineCode",{parentName:"li"},"'")," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"'),", such as ",(0,l.kt)("inlineCode",{parentName:"li"},"' a '"),".\nIf you encounter characters like ",(0,l.kt)("inlineCode",{parentName:"li"},"'")," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},",")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"{")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"}")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"\\n")," in a string, you need to escape them with the ",(0,l.kt)("inlineCode",{parentName:"li"},"\\")," character, for example, ",(0,l.kt)("inlineCode",{parentName:"li"},"'abc\\{\\}\\'\\\"'\\t\\n\\\\"),"."),(0,l.kt)("li",{parentName:"ul"},"Containers and beans (except beans with null values) need to start with ",(0,l.kt)("inlineCode",{parentName:"li"},"{")," and end with ",(0,l.kt)("inlineCode",{parentName:"li"},"}"),".")),(0,l.kt)("p",null,"The example configuration is as follows:"),(0,l.kt)("p",null,"Single-line filling method:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"{ 1122, false, 2, 128, 112233445566, 1.3, 1122, yf, {1}, D, {DemoD2,1,3}, 1970-01-01 00:00:00, {1,2}, {2,3}, {{2,10},{3,12}}, {{1,true},{2,false}}, {{DemoD2,1,3}}}\n\n")),(0,l.kt)("p",null,"Multi-line filling method for better readability:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"{\n  1122,\n  false,\n  2,\n  128,\n  112233445566,\n  1.3,\n  1122,\n  yf,\n  {1},\n  D,\n  {DemoD2,1,3},\n  1970-01-01 00:00:00,\n  {1,2},\n  {2,3},\n  {{2,10},{3,12}},\n  {{1,true},{2,false}},\n  {{DemoD2,1,3}}\n}\n")),(0,l.kt)("h2",{id:"compound-file-format"},"Compound file format"),(0,l.kt)("p",null,"If a file contains multiple records, you need to add ",(0,l.kt)("inlineCode",{parentName:"p"},"*@")," before the file name, indicating that the file contains a list of records instead of a single record.\nHere we take the json format as an example. The inputFiles of table have the following formats:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"xxx.json"),", read xxx.json as a record.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"*@xxx.json"),", read xxx.json as a list of records.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"field@xxx.json"),", read the field field in xxx.json as a record. field can be a deep-level field, such as a.b.c.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"*field@xxx.json"),", read the field field in xxx.json as a list of records. field can be a deep level field."))),(0,l.kt)("p",null,"Interestingly, similar to xlsx data source, it supports putting multiple tables into the same json, but it is rarely done in practice."),(0,l.kt)("p",null,"As shown in the following example:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"TbCompositeJsonTable1 reads a list of records from the table1 field of composite_tables.json, reads a list of records from composite_tables2.json, and reads a record from one_record.json"),(0,l.kt)("li",{parentName:"ul"},"TbCompositeJsonTable2 reads a list of records from the table2 field of composite_tables.json"),(0,l.kt)("li",{parentName:"ul"},"TbCompositeJsonTable3 reads a record from the table3 field of composite_tables.json")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<bean name="CompositeJsonTable1">\n<var name="id" type="int"/>\n<var name="x" type="string"/>\n</bean>\n<bean name="CompositeJsonTable2">\n<var name="id" type="int"/>\n<var name="y" type="int"/>\n</bean>\n<bean name="CompositeJsonTable3">\n<var name="a" type="int"/>\n<var name="b" type="int"/>\n</bean>\n\n<table name="TbCompositeJsonTable1" value="CompositeJsonTable1" input="*table1@composite_tables.json,*@composite_tables2.json,one_record.json"/>\n<table name="TbCompositeJsonTable2" value="CompositeJsonTable2" input="*table2@composite_tables.json"/>\n<table name="TbCompositeJsonTable3" value="CompositeJsonTable3" mode="one" input="table3@composite_tables.json"/>\n')))}u.isMDXComponent=!0}}]);