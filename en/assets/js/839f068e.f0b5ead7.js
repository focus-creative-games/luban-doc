"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9730],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),m=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=m(n),c=r,f=d["".concat(s,".").concat(c)]||d[c]||u[c]||o;return n?a.createElement(f,l(l({ref:t},p),{},{components:n})):a.createElement(f,l({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:r,l[1]=i;for(var m=2;m<o;m++)l[m]=n[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4086:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>m});var a=n(7462),r=(n(7294),n(3905));const o={},l="Non-excel data format",i={unversionedId:"manual/otherdatasource",id:"manual/otherdatasource",title:"Non-excel data format",description:"Most of the data format filling methods are intuitive, and the data definitions are exactly the same.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/otherdatasource.md",sourceDirName:"manual",slug:"/manual/otherdatasource",permalink:"/en/docs/manual/otherdatasource",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"excel format (advanced)",permalink:"/en/docs/manual/exceladvanced"},next:{title:"Code and Data Generation",permalink:"/en/docs/manual/generatecodedata"}},s={},m=[{value:"The type used for the demo",id:"the-type-used-for-the-demo",level:2},{value:"data directory",id:"data-directory",level:2},{value:"Single record format",id:"single-record-format",level:2},{value:"json format",id:"json-format",level:3},{value:"lua format",id:"lua-format",level:3},{value:"xml format",id:"xml-format",level:3},{value:"yaml format",id:"yaml-format",level:3},{value:"Composite file format",id:"composite-file-format",level:2}],p={toc:m},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"non-excel-data-format"},"Non-excel data format"),(0,r.kt)("p",null,"Most of the data format filling methods are intuitive, and the data definitions are exactly the same."),(0,r.kt)("h2",{id:"the-type-used-for-the-demo"},"The type used for the demo"),(0,r.kt)("p",null,"Take the following DemoType2 as an example to show how to fill in the corresponding data of this type in other file formats."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<bean name="DemoType2" >\n  <var name="x4" type="int"/>\n  <var name="x1" type="bool"/>\n  <var name="x5" type="long"/>\n  <var name="x6" type="float"/>\n  <var name="x7" type="double"/>\n  <var name="x10" type="string"/>\n  <var name="x12" type="DemoType1"/>\n  <var name="x13" type="DemoEnum"/>\n  <var name="x14" type="DemoDynamic#sep=,"/>\n  <var name="t1" type="datetime"/>\n  <var name="k1" type="array,int"/>\n  <var name="k2" type="list,int"/>\n  <var name="k8" type="map,int,int"/>\n  <var name="k9" type="(list#sep=,#index=y1),DemoE2"/>\n  <var name="k15" type="(array#sep=,),DemoDynamic"/> \n</bean>\n\n<table name="TbDataFromSingle" value="DemoType2" input="test/datas"/> \n')),(0,r.kt)("h2",{id:"data-directory"},"data directory"),(0,r.kt)("p",null,"If table.inputFiles points to a directory, it will automatically traverse the entire directory tree, ignore files beginning with ",(0,r.kt)("inlineCode",{parentName:"p"},".~_")," characters, and input the remaining files as data files.\nThese data file formats correspond to the following single-record formats. Note that if an excel file is encountered, it still tries to read multiple records from a file by default."),(0,r.kt)("h2",{id:"single-record-format"},"Single record format"),(0,r.kt)("h3",{id:"json-format"},"json format"),(0,r.kt)("p",null,"Some special points of json format:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"set type. Filling method is ",(0,r.kt)("inlineCode",{parentName:"li"},"[v1,v2,...]")),(0,r.kt)("li",{parentName:"ul"},"map type. Since json only supports keys of string type, the map format filling method is ",(0,r.kt)("inlineCode",{parentName:"li"},"[[k1,v1],[k2,v2]...]")),(0,r.kt)("li",{parentName:"ul"},"Polymorphic bean types. The ",(0,r.kt)("inlineCode",{parentName:"li"},"$type")," attribute is required to specify the concrete type name")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "x1": true,\n   "x2": 3,\n   "x3": 128,\n   "x4": 1,\n   "x5":11223344,\n   "x6":1.2,\n   "x7":1.23432,\n   "x10": "hq",\n   "x12": { "x1":10},\n   "x13": "B",\n   "x14":{"$type": "DemoD2", "x1":1, "x2":2},\n   "t1": "1970-01-01 00:00:00",\n   "k1":[1,2],\n   "k2":[2,3],\n   "k7":[2,3],\n   "k8":[[2,2],[4,10]],\n   "k9":[{"y1":1, "y2":true},{"y1":2, "y2":false}],\n   "k15":[{"$type": "DemoD2", "x1":1, "x2":2}]\n}\n')),(0,r.kt)("h3",{id:"lua-format"},"lua format"),(0,r.kt)("p",null,"Lua data source features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"There is a return before the data, because the lua data is loaded as a lua file, and each loaded result is read as a record"),(0,r.kt)("li",{parentName:"ul"},"The format of the set is ",(0,r.kt)("inlineCode",{parentName:"li"},"{v1, v2, ...}")),(0,r.kt)("li",{parentName:"ul"},"Unlike json, the key of lua's table supports any format, so lua's map can directly ",(0,r.kt)("inlineCode",{parentName:"li"},"{[key1] = value1, [key2] = value2, ,,,}")),(0,r.kt)("li",{parentName:"ul"},"Polymorphic bean types. The ",(0,r.kt)("inlineCode",{parentName:"li"},"_type_")," attribute is required to specify the concrete type name")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'return\n{\n   x1 = false,\n   x2 = 2,\n   x3 = 128,\n   x4 = 1122,\n   x5 = 112233445566,\n   x6 = 1.3,\n   x7 = 1122,\n   x10 = "yf",\n   x12 = {x1=1},\n   x13 = "D",\n   x14 = { _type_="DemoD2", x1 = 1, x2=3},\n   t1 = "1970-01-01 00:00:00",\n   k1 = {1,2},\n   k2 = {2,3},\n   k8 = {[2]=10,[3]=12},\n   k9 = { {y1=1,y2=true}, {y1=10,y2=false} },\n   k15 = { { _type_="DemoD2", x1 = 1, x2=3} },\n}\n')),(0,r.kt)("h3",{id:"xml-format"},"xml format"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<data>\n   <x1>true</x1>\n   <x2>4</x2>\n   <x3>128</x3>\n   <x4>1</x4>\n   <x5>112233445566</x5>\n   <x6>1.3</x6>\n   <x7>1112232.43123</x7>\n   <x10>yf</x10>\n   <x12> <x1>1</x1> </x12>\n   <x13>C</x13>\n   <x14 type="DemoD2"> <x1>1</x1> <x2>2</x2> </x14>\n   <k1> <item>1</item> <item>2</item> </k1>\n   <k2> <item>1</item> <item>2</item> </k2>\n   <k8>\n       <item> <key>2</key><value>10</value></item>\n       <item> <key>3</key><value>30</value></item>\n   </k8>\n   <k9>\n       <item> <y1>1</y1> <y2>true</y2> </item>\n       <item> <y1>2</y1> <y2>false</y2> </item>\n   </k9>\n   <k15>\n       <item type="DemoD2"> <x1>1</x1> <x2>2</x2> </item>\n   </k15>\n</data>\n')),(0,r.kt)("h3",{id:"yaml-format"},"yaml format"),(0,r.kt)("p",null,"The characteristics of yaml format are similar to json:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"set type. The filling method corresponds to the json list ",(0,r.kt)("inlineCode",{parentName:"li"},"[v1,v2,...]")),(0,r.kt)("li",{parentName:"ul"},"map type. Since json only supports keys of string type, the map format filling method is for the kv list in json ",(0,r.kt)("inlineCode",{parentName:"li"},"[[k1,v1],[k2,v2]...]")),(0,r.kt)("li",{parentName:"ul"},"Polymorphic bean types. The ",(0,r.kt)("inlineCode",{parentName:"li"},"$type")," attribute is required to specify the concrete type name")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"x1: true\nx2: 3\nx3: 128\nx4: 40\nx5: 11223344\nx6: 1.2\nx7: 1.23432\nx10: hq\nx12:\n   x1: 10\nx13: B\nx14:\n   $type: DemoD2\n   x1: 1\n   x2: 2\nt1: '1970-01-01 00:00:00'\nk1:\n- 1\n- 2\nk2:\n- 2\n- 3\nk8:\n- - 2\n   - 2\n- - 4\n   - 10\nk9:\n- y1: 1\n   y2: true\n- y1: 2\n   y2: false\nk15:\n- $type: DemoD2\n   x1: 1\n   x2: 2\n")),(0,r.kt)("h2",{id:"composite-file-format"},"Composite file format"),(0,r.kt)("p",null,"If a file contains multiple records, you need to add ",(0,r.kt)("inlineCode",{parentName:"p"},"*@")," before the file name, indicating that the file contains a list of records, not a record.\nHere we take the json format as an example. The inputFiles of the table have the following formats:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"xxx.json"),", read xxx.json as a record."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*@xxx.json"),", read xxx.json as a list of records."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"field@xxx.json"),", read the field field in xxx.json as a record. field can be a deep-level field, such as a.b.c."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*field@xxx.json"),", read the field field in xxx.json as a list of records. field can be a deep field.")),(0,r.kt)("p",null,"What's more interesting is that, similar to the xlsx data source, it supports putting multiple tables into the same json, but this is rarely done in practice."),(0,r.kt)("p",null,"As the following example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"TbCompositeJsonTable1 reads a list of records from the table1 field of composite_tables.json, reads a list of records from composite_tables2.json, and reads a record from one_record.json"),(0,r.kt)("li",{parentName:"ul"},"TbCompositeJsonTable2 reads a list of records from the table2 field of composite_tables.json"),(0,r.kt)("li",{parentName:"ul"},"TbCompositeJsonTable3 reads a record from the table3 field of composite_tables.json")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<bean name="CompositeJsonTable1">\n     <var name="id" type="int"/>\n     <var name="x" type="string"/>\n</bean>\n<bean name="CompositeJsonTable2">\n     <var name="id" type="int"/>\n     <var name="y" type="int"/>\n</bean>\n<bean name="CompositeJsonTable3">\n     <var name="a" type="int"/>\n     <var name="b" type="int"/>\n</bean>\n\n<table name="TbCompositeJsonTable1" value="CompositeJsonTable1" input="*table1@composite_tables.json,*@composite_tables2.json,one_record.json"/>\n<table name="TbCompositeJsonTable2" value="CompositeJsonTable2" input="*table2@composite_tables.json"/>\n<table name="TbCompositeJsonTable3" value="CompositeJsonTable3" mode="one" input="table3@composite_tables.json"/>\n')))}u.isMDXComponent=!0}}]);